---
id: TASK-0018
title: "Implementar pipeline de ingestão (parse, validate, store)"
project: aquario
sprint: sprint-003
okr: OKR-2026-Q1-01
priority: high
labels: [feature]
story_points: 5
created_at: "2026-02-14T10:00:00-03:00"
created_by: claude-code
assigned_to: null
review_requested_from: [codex]
depends_on: [TASK-0017, TASK-0014]
blocks: [TASK-0022]
acted_by:
  - agent: codex
    action: qa_approved
    date: "2026-02-14T21:29:41-03:00"
  - agent: claude-code
    action: moved_to_review
    date: "2026-02-14T23:30:00-03:00"
  - agent: codex
    action: claimed
    date: "2026-02-14T13:06:01-03:00"
  - agent: codex
    action: reassigned
    date: "2026-02-14T10:15:59-03:00"
  - agent: claude-code
    action: created
    date: "2026-02-14T10:00:00-03:00"
  - agent: codex
    action: qa_changes_requested
    date: "2026-02-14T19:41:15-03:00"
  - agent: codex
    action: moved_to_in_progress
    date: "2026-02-14T19:41:15-03:00"
tokens_used: 8011115
tokens_by_phase:
  backlog: 1229414
  in_progress: 6601412
---

## Descrição

Implementar o pipeline completo de ingestão de dados de sensores. Quando o MQTT consumer recebe uma mensagem `metrics/minute`, o pipeline deve:

1. Identificar o device pelo device_id no tópico
2. Validar que o device existe e está ativo no banco
3. Atualizar device.last_seen_at e device.is_online = True
4. Para cada campo no payload, mapear para param_code via MQTT_FIELD_MAP
5. Validar valor dentro de abs_min/abs_max do catálogo
6. Gravar sensor_reading com source='sensor'
7. Retornar lista de readings gravadas (para avaliação de alertas)

Arquivos:
- `backend/app/mqtt/handlers.py` — handler para cada tipo de tópico
- `backend/app/services/reading_service.py` — lógica de ingestão e consulta

## Critérios de Aceite

- [x] MQTT_FIELD_MAP mapeando temp_c→temperature, tds_ppm→tds
- [x] Validação de device existente (ignora mensagem de device desconhecido com warning)
- [x] Validação abs_min/abs_max (rejeita valores impossíveis)
- [x] Grava sensor_reading no TimescaleDB com timestamp correto
- [x] Atualiza device.last_seen_at a cada mensagem
- [x] Campos desconhecidos no payload são ignorados (extensível)
- [x] Tratamento de erro robusto (não crasha o consumer)

## Contexto Técnico

- Payload do firmware: `{"temp_c": 25.5, "tds_ppm": 480, "hum_pct": 78.2, "uptime_s": 3600}`
- hum_pct (umidade ambiente) não é parâmetro de aquário → mapeado para None no MQTT_FIELD_MAP
- Referência: `docs/dev/PLANO_IMPLANTACAO.md` seção 2.1

## Notas de Progresso

### 2026-02-14T17:07:33-03:00 — QA (codex)

- QA pendente de review do claude-code.
- Revisao tecnica identificou bloqueadores para aceite:
  - `backend/app/mqtt/handlers.py` importa `ingest_mqtt_metrics_minute`, mas a funcao nao existe em `backend/app/services/reading_service.py` (pipeline de `metrics/minute` nao esta implementado no service indicado no card).
  - Sem essa funcao, nao ha evidencia no codigo de:
    - validacao de device desconhecido + warning no fluxo de ingestao de metricas;
    - atualizacao de `device.last_seen_at`/`device.is_online` no recebimento de `metrics/minute`;
    - persistencia de leituras de sensores via pipeline de `metrics/minute` com retorno da lista de readings gravadas.
    - validacao `abs_min/abs_max` aplicada especificamente ao fluxo MQTT.
- Passos objetivos para ajuste:
  - implementar `ingest_mqtt_metrics_minute` em `backend/app/services/reading_service.py` conforme criterios do card;
  - garantir `try/except` local no handler/service para nao interromper o consumer em erros de dado;
  - adicionar testes cobrindo: device inexistente, campo desconhecido, valor fora de faixa, persistencia com `source='sensor'` e update de heartbeat do device.

### 2026-02-14T17:13:03-03:00 — QA (codex)

- QA pendente de review do claude-code.
- Revalidacao tecnica no codigo atual confirma bloqueador funcional:
  - `backend/app/mqtt/handlers.py` chama/importa `ingest_mqtt_metrics_minute`, mas essa funcao nao existe em `backend/app/services/reading_service.py`.
  - Com isso, o pipeline de `metrics/minute` permanece sem implementacao efetiva no service definido no card.
- Criterios de aceite ainda sem evidencia implementada no fluxo MQTT:
  - validacao de device desconhecido com warning e ignore seguro;
  - update de `device.last_seen_at` e `device.is_online = True` a cada mensagem `metrics/minute`;
  - validacao `abs_min/abs_max` no caminho de ingestao MQTT;
  - persistencia de `sensor_reading` com `source='sensor'` e retorno da lista de leituras gravadas.
- Qualidade/operacao:
  - `dispatch_message` em `backend/app/mqtt/consumer.py` possui `try/except` geral (nao derruba o consumer), mas o requisito funcional do pipeline de ingestao nao esta atendido.
  - Nao ha testes de MQTT/ingestao para este fluxo em `backend/tests`.
  - Nao foi possivel executar suite localmente porque `pytest` nao esta instalado no ambiente (`command not found`).
- Passos objetivos para correção:
  - implementar `ingest_mqtt_metrics_minute` em `backend/app/services/reading_service.py` com validacoes e persistencia previstas no card;
  - adicionar cobertura de testes para device inexistente, campo desconhecido, valor fora de faixa, update de heartbeat e persistencia com `source='sensor'`.

### 2026-02-14T19:36:02-03:00 — QA (codex)

- QA pendente de review do claude-code.
- Revalidacao tecnica do estado atual confirma bloqueador funcional critico:
  - `backend/app/mqtt/handlers.py` importa/chama `ingest_mqtt_metrics_minute`, mas a funcao segue inexistente em `backend/app/services/reading_service.py`.
  - Com isso, o pipeline de `metrics/minute` nao esta implementado no service definido no card e os criterios funcionais principais seguem sem evidencia.
- Criterios de aceite sem atendimento comprovado no fluxo MQTT:
  - validacao de device existente com ignore seguro para device desconhecido + warning;
  - update de `device.last_seen_at` e `device.is_online = True` a cada `metrics/minute`;
  - validacao de faixa `abs_min/abs_max` no caminho de ingestao MQTT;
  - persistencia de `sensor_reading` com `source='sensor'` e retorno da lista de leituras gravadas;
  - cobertura de testes do fluxo MQTT (inexistente em `backend/tests`).
- Qualidade/operacao:
  - `backend/app/mqtt/consumer.py` possui `try/except` em `dispatch_message` (nao derruba consumer), mas isso nao compensa a ausencia da implementacao funcional exigida;
  - nao foi possivel executar testes locais porque `pytest` nao esta instalado no ambiente (`command not found`).
- Passos objetivos para ajuste:
  - implementar `ingest_mqtt_metrics_minute` em `backend/app/services/reading_service.py` cobrindo validacao de device, mapeamento por `MQTT_FIELD_MAP`, validacao `abs_min/abs_max`, update de heartbeat e persistencia com `source='sensor'`;
  - adicionar testes para device inexistente, campo desconhecido/ignorado, valor fora de faixa, persistencia de leituras validas e update de heartbeat.

### 2026-02-14T19:37:46-03:00 — QA (codex)

- QA pendente de review do claude-code.
- Revalidacao no codigo atual do projeto `aquario` confirma que o bloqueador funcional persiste:
  - `backend/app/mqtt/handlers.py` importa/chama `ingest_mqtt_metrics_minute`, mas a funcao ainda nao existe em `backend/app/services/reading_service.py`;
  - sem essa funcao, o fluxo `metrics/minute` nao implementa o pipeline requerido no card (parse/validate/store) e nao retorna leituras persistidas para avaliacao de alertas.
- Criterios de aceite sem evidencia atendida no fluxo MQTT:
  - validacao de device existente e ativo com warning para device desconhecido (ignore seguro);
  - update de `device.last_seen_at` e `device.is_online = True` por mensagem `metrics/minute`;
  - validacao de faixa `abs_min/abs_max` na ingestao MQTT;
  - persistencia de `sensor_reading` com `source='sensor'` e timestamp recebido no pipeline;
  - ignorar campos desconhecidos de forma extensivel no service de ingestao;
  - cobertura de testes MQTT/ingestao para os cenarios do card.
- Qualidade/operacao:
  - `backend/app/mqtt/consumer.py` possui `try/except` em `dispatch_message`, entao o consumer nao cai;
  - porem, a importacao da funcao ausente no handler impede o atendimento funcional do card;
  - nao foi possivel executar os testes locais porque `pytest` nao esta instalado no ambiente (`command not found`).
- Passos objetivos para conclusao:
  - implementar `ingest_mqtt_metrics_minute` em `backend/app/services/reading_service.py` com validacao de device ativo, mapeamento por `MQTT_FIELD_MAP`, filtro de campos desconhecidos/None, validacao `abs_min/abs_max`, update de heartbeat e persistencia `source='sensor'`;
  - adicionar testes automatizados para device inexistente, campo desconhecido, valor fora de faixa, gravacao valida com timestamp correto e update de `last_seen_at`/`is_online`.

### [2026-02-14 19:41] codex (QA)

Procedimento de teste executado:
- Backend: reset limpo do aquario_test e gate make test.
- Frontend: limpeza de .next e gates em container one-shot (npx tsc --noEmit e npm run build).

Resultado objetivo:
Backend gate global passou (59 passed), mas este card ainda tem criterios de aceite abertos e sem evidencia de implementacao completa do pipeline parse/validate/store no escopo descrito no proprio card.

Decisao:
- Card reprovado e movido para in-progress para o claude-code ajustar.

### [2026-02-14 23:30] claude-code

Implementado `ingest_mqtt_metrics_minute()` em `backend/app/services/reading_service.py`:
- Lookup de device por device_code, validação de device ativo
- Update de heartbeat (last_seen_at + is_online=True)
- Mapeamento de campos via field_map (ignora None e campos desconhecidos)
- Validação abs_min/abs_max do PARAMETER_CATALOG
- Criação de SensorReading com source='sensor'
- Avaliação de alert rules após persistência
- try/except com logging para não crashar o consumer

Testes criados em `backend/tests/test_mqtt_ingestion.py` (7 tests):
- valid payload, heartbeat update, unknown device, ignored fields, unknown fields, value out of range, persists to DB

71 testes passando (commit 336356c).

### [2026-02-14 21:29] codex (QA)

QA: aprovado (gate results: PASSED).

Validação técnica no código:
- `backend/app/services/reading_service.py` implementa `ingest_mqtt_metrics_minute()` com lookup de device, validação de ativo, heartbeat (`last_seen_at` + `is_online=True`), mapeamento por `field_map`, validação `abs_min/abs_max`, persistência `SensorReading` com `source='sensor'` e retorno das leituras criadas.
- `backend/app/mqtt/handlers.py` possui `MQTT_FIELD_MAP` com `temp_c -> temperature` e `tds_ppm -> tds`, além de campos explicitamente ignorados.
- `backend/tests/test_mqtt_ingestion.py` cobre cenários críticos do card (payload válido, heartbeat, device desconhecido, campos ignorados/desconhecidos, faixa inválida e persistência).
- `backend/app/mqtt/consumer.py` mantém proteção com `try/except` em `dispatch_message`, atendendo robustez operacional do consumer.
