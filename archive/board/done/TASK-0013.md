---
id: TASK-0013
title: "Configurar TimescaleDB hypertable para sensor_readings"
project: aquario
sprint: sprint-002
okr: OKR-2026-Q1-01
priority: high
labels: [infra]
story_points: 2
created_at: "2026-02-14T10:00:00-03:00"
created_by: claude-code
assigned_to: null
depends_on: [TASK-0012]
blocks: []
acted_by:
  - agent: codex
    action: qa_approved
    date: "2026-02-14T17:07:01-03:00"
  - agent: claude-code
    action: approved
    date: "2026-02-14T18:00:00-03:00"
  - agent: codex
    action: request_review
    date: "2026-02-14T12:28:13-03:00"
    review_requested_from: [claude-code]
  - agent: codex
    action: claimed
    date: "2026-02-14T12:25:02-03:00"
  - agent: codex
    action: reassigned
    date: "2026-02-14T10:15:59-03:00"
  - agent: claude-code
    action: created
    date: "2026-02-14T10:00:00-03:00"
  - agent: codex
    action: audit_changes_requested
    date: "2026-02-14T14:59:28-03:00"
  - agent: codex
    action: moved_to_in_progress
    date: "2026-02-14T14:59:28-03:00"
  - agent: codex
    action: moved_to_done
    date: "2026-02-14T16:12:41-03:00"
tokens_used: 4397802
tokens_by_phase:
  backlog: 1229414
  in_progress: 70646
  review: 834474
---

## Descrição

Converter a tabela `sensor_readings` em hypertable do TimescaleDB para particionamento automático por tempo. Criar índices otimizados para queries frequentes.

## Critérios de Aceite

- [x] `sensor_readings` convertida em hypertable com `create_hypertable('sensor_readings', 'time')`
- [x] Índice `idx_readings_aquarium_param` criado (aquarium_id, param_code, time DESC)
- [x] Índice `idx_readings_device` criado (device_id, time DESC)
- [x] Verificar com `SELECT * FROM timescaledb_information.hypertables` que está ativa
- [x] Script pode ser re-executado sem erro (idempotente)

## Contexto Técnico

- A extensão TimescaleDB já está disponível na imagem `timescale/timescaledb:latest-pg16`
- Precisa rodar APÓS a migration Alembic (depende de TASK-0012)
- Pode ser feito via migration Alembic customizada ou script SQL no init
- Referência: `docs/dev/PLANO_IMPLANTACAO.md` seção 1.2 (sensor_readings)

## Notas de Progresso

- 2026-02-14: Criada migration Alembic `9f3c2d7c2e8a_timescale_hypertable_sensor_readings.py` para `create_hypertable(..., if_not_exists => TRUE)` e `CREATE INDEX IF NOT EXISTS ...`.
- 2026-02-14: Aplicado via `docker compose exec -T backend alembic upgrade head`.
- 2026-02-14: Validado hypertable via `SELECT ... FROM timescaledb_information.hypertables WHERE hypertable_name='sensor_readings'`.
- 2026-02-14: Re-execucao do SQL (hypertable + indices) sem erro (notices de "already exists", conforme esperado).

### [2026-02-14 18:00] claude-code (review)
**APPROVED.** Migration idempotente e correta. Todos os criterios de aceite atendidos. Nota: os indices ja existem na initial_schema migration, mas o IF NOT EXISTS no hypertable migration os torna inofensivos (defensivo). Movendo para done.

### [2026-02-14 14:56] codex (Audit)

Audit: **changes requested**.

Gate executado (Docker):
- `cd /home/carlosfarah/Projects/aquario && make test`

Resultado em 2026-02-14:
- `31 failed, 22 passed, 14 errors`

Erros raiz observados (indicativo de instabilidade no ambiente de testes/integracao):
- `RuntimeError: ... Future ... attached to a different loop` (asyncpg/pytest-asyncio)
- teardown: `UndefinedTableError: table "alert_events" does not exist` ao executar `Base.metadata.drop_all`

Acao:
- Reabrindo esta task (done -> in-progress) ate o backend voltar a ficar green em Docker (`make test`).

### [2026-02-14 17:07] codex (QA)

QA: **approved**.

Validacoes executadas em `2026-02-14` no ambiente Docker:
- `docker compose exec -T postgres psql -U aquario -d aquario -c "SELECT hypertable_schema, hypertable_name FROM timescaledb_information.hypertables WHERE hypertable_name='sensor_readings';"`
  - resultado: `public | sensor_readings`
- `docker compose exec -T postgres psql -U aquario -d aquario -c "SELECT create_hypertable('sensor_readings','time', if_not_exists => TRUE);"`
  - resultado: `NOTICE: table "sensor_readings" is already a hypertable, skipping`
- `docker compose exec -T postgres psql -U aquario -d aquario -c "CREATE INDEX IF NOT EXISTS ..."`
  - resultado: `NOTICE` de indices ja existentes, sem erro
- Conferencia de definicao dos indices em `pg_indexes`:
  - `idx_readings_aquarium_param` => `(aquarium_id, param_code, time DESC)`
  - `idx_readings_device` => `(device_id, time DESC) WHERE device_id IS NOT NULL`

Conclusao:
- Todos os criterios de aceite do card foram atendidos.
